# =====================================================================
#
#           FILE : rvsh
#
#          USAGE : rvsh.sh [--admin | --connect <hostname> <username>]
#
#    DESCRIPTION : fichier source de la commande lsc
#
#
#         OPTION : 
#           -h, --help       show this help message and quit
#           -a, --admin      log in the virtual machine as administrator
#           -c, --connect    log in the virtual machine as simple user
#                            you must specify the hostname and the username.
#                             (you can connect as a guest, use guest 
#                            for both username and h
#           -i, --install    install this program and exit
#           -u, --uninstall  uninstall this program and exit
#         
#         AUTHOR : GaÃ«l Mahfoudi & Simon Juhel
#        COMPANY : UTT
#        VERSION : 1.0
#
# =====================================================================


# === INCLUDES ========================================================

# admin
source commands/admin/afinger.sh
source commands/admin/users.sh
source commands/admin/host.sh
source commands/admin/lsc.sh

# shared
source commands/shared/handle_connections.sh
source commands/shared/rvsh_cd.sh
source commands/shared/rvsh_ls.sh
source commands/shared/rvsh_mkdir.sh
source commands/shared/rvsh_rm.sh

# users
source commands/users/connect.sh
source commands/users/finger.sh
source commands/users/msg.sh
source commands/users/passwd.sh
source commands/users/rhost.sh
source commands/users/rusers.sh
source commands/users/su.sh
source commands/users/who.sh
source commands/users/write.sh

# =====================================================================


# === GLOBAL VARIABLES ================================================

ROOT="$HOME/rvsh"


NC='\e[0m'              # Text Reset
BLACK='\e[0;30m'        # Black
RED='\e[0;31m'          # Red
GREEN='\e[0;32m'        # Green
YELLOW='\e[0;33m'       # Yellow
BLUE='\e[0;34m'         # Blue
PURPLE='\e[0;35m'       # Purple
CYAN='\e[0;36m'         # Cyan
WHITE='\e[0;37m'        # White

# =====================================================================


# ==== FUNCTION =======================================================
#
#        NAME : usage
# DESCRIPTION : aide de la cli de rvsh
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
usage() {

    echo "Usage: $(basename $0) [--admin | --connect <hostname> <username>]"
    echo ""
    echo "  -h, --help       show this help message and quit"
    echo "  -a, --admin      log in the virtual machine as administrator"
    echo "  -c, --connect    log in the virtual machine as simple user"
    echo "                   you must specify the hostname and the username."
    echo "  -i, --install    install this program and exit"
    echo "  -u, --uninstall  uninstall this program and exit"
    echo ""
    
    exit 1
}


# ==== FUNCTION =======================================================
#
#        NAME : install
# DESCRIPTION : installe le programme rvsh
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
install() {

    echo "(install) rvsh will be installed in '$ROOT':"

    # on cree le repertoire racine
    mkdir $ROOT

    # on extrait l'architecture de rvsh dans le 
    # repertoire racine
    tar xvzf ./install/filesystem.tar.gz -C $ROOT/

    # on configure le mot de passe administrateur
    echo ""
    read -p "(install) Enter the admin password please: " -s adminpass
    echo "$(echo "$adminpass" | md5sum | cut -d' ' -f1)" > $ROOT/users/admin/password
    echo ""
    echo "(install) Admin password has been set"
    echo "(install) Done"

    exit 0
}


# ==== FUNCTION =======================================================
#
#        NAME : uninstall
# DESCRIPTION : desinstalle le programme rvsh
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
uninstall() {

    echo "(uninstall) rvsh will be uninstalled"; sleep 1.5
    rm -r $ROOT/        # suppression de l'architecture personnelle
    echo "(uninstall) Done"
    exit 0
}


# ==== FUNCTION =======================================================
#
#        NAME : ReadKey
# DESCRIPTION : Lis les entrÃ©es claviers lettre par lettre, lis le
#               tampon si un caractÃ¨re spÃ©cial a Ã©tÃ© saisis.
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
ReadKey() {
    # On attends le premier caractÃ¨re
    if IFS="" read -n1 _REPLY; then
      # On lit le reste du tampon
      while read -n1 -t 0.001 ; do
        _REPLY+="${REPLY}"
      done
    fi
}


# ==== FUNCTION =======================================================
#
#        NAME : history_cmd
# DESCRIPTION : GÃ¨re l'appuie des touches spÃ©ciales (haut,bas backspace)
#               afin de mettre en place le systÃ¨me d'historique de 
#               commande.
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
history_cmd() {

    if [ ! -e $ROOT/hist ]  #Si le fichier hist n'existe pas, on le crÃ©e
    then
        touch $ROOT/hist
        echo -e "\n" >> $ROOT/hist
    fi


    stop="n" #Indicateur d'arrÃªt de la lecture de la commande      
    i=$((1)) #NumÃ©ro de ligne de la commande Ã  rÃ©cupÃ©rer
    tailleHist=$(($(cat $ROOT/hist | wc -l))) #Nombre de ligne de l'historique de commande
    cmd="" #La commande Ã©crite
    posCurs=$((0)) #Position du curseur dans la commande


    while [ "$stop" = "n" ] #Tant que l'utilisateur saisit des caractÃ¨res 
    do

        stop="o" 

        
        #On efface la ligne courante, puis on Ã©crit le prompt ainsi que la commande de l'utilisateur.
        #On revient au dÃ©but de ligne, puis on rÃ©ecrit le prompt et la commande jusqu'Ã  la position du curseur.
        tmpCmd=${cmd:0:$(($posCurs))} #
        echo -en "\r$(echo "$1 $cmd" | sed 's/./ /g')    \r"
        echo -en "$1 $cmd"
        echo -en "\r"
        echo -en "$1 $tmpCmd"
        

      tailleCmd=${#cmd} #On actualise la taille de la commande
      ReadKey #on lit l'entrÃ©e clavier

      
      case $_REPLY in
        [A) #Si on appuie sur la touche HAUT

                i=$((i-1)) #On monte d'une ligne dans le fichier historique

                if [ $i -eq 0 ] #Si on est en haut, on retourne en bas
                then
                  i=$((tailleHist))
                fi

                cmd=$(sed -n ${i}p $ROOT/hist) #On actualise la commande

                posCurs=$((${#cmd}+1)) #On actualise la position du curseur

                stop="n";;


        [B ) #Si on appuie sur la touche BAS


                i=$((i+1)) #On descend d'une ligne dans le fichier historique

                if [ $i -eq $(($tailleHist+1)) ] #Si on est en bas, on retourne en haut
                then
                  i=$((1))
                fi

                cmd=$(sed -n ${i}p $ROOT/hist) #On actualise la commande

                posCurs=$((${#cmd}+1)) #On actualise la position du curseur

                stop="n";;

        [C ) #Si on appuie sur la touche DROITE
                if [ ! $posCurs -eq $tailleCmd  ] #On bouge le curseur Ã  droite si il n'est pas au bout de la commande
                then
                    posCurs=$(($posCurs+1))
                fi


                stop="n"
                ;;

        [D ) #Si on appuie sur la touche GAUCHE
                if [ ! $posCurs -eq 0 ] #On bouge le curseur Ã  gauche si il n'est pas au dÃ©but de la commande
                then
                    posCurs=$(($posCurs-1))
                fi

                stop="n"
                ;;

        )      #Si on appuie sur la touche Effacer
                if [ "$cmd" != "" ] #Si la commande n'est pas vide
                then
                  cmd=${cmd:0:$(($posCurs-1))}${cmd:$posCurs} #On supprime le caractÃ¨re juste avant le curseur
                  tailleCmd=$(($tailleCmd-1)) #On diminue la taille de la commande de 1
                  if [ ! $posCurs -eq 0 ] #Si le curseur n'est pas Ã  0 on le fait reculer d'un caractÃ¨re
                  then
                    posCurs=$(($posCurs-1))
                  fi
                else    #Si la commande est vide on ne fait rien
                  cmd=""
                fi
                stop="n";;

        "")     stop="o";; #Si on appuie sur ENTREE on quitte

        *)      #Si un caractÃ¨re a Ã©tÃ© saisit

                tmpCmdStart=${cmd:0:$(($posCurs))} #On rÃ©cupÃ¨re le dÃ©but de la commande jusqu'au curseur
                tmpCmdEnd=${cmd:$(($posCurs))}     #On rÃ©cupÃ¨re la fin de la commande aprÃ¨s le curseur
                cmd=$tmpCmdStart$_REPLY$tmpCmdEnd  #On insÃ¨re le caractÃ¨re Ã  la position du curseur
                tailleCmd=$(($tailleCmd+1))        #On augmente la taille de la commande
                posCurs=$(($posCurs+1))            #On augmente la position du curseur
                stop="n";;
      esac
    done

    if [ "$cmd" != "" ]         #Si la commande saisit n'Ã©tait pas vide on l'ajoute Ã  l'historique
    then
        echo -e "$cmd" >> $ROOT/hist
    fi
}


handle_users_cmd() {


    local username="$1"
    local hostname="$2"
    local ctime="$3"
    local cmd=""    # commande entree par l'utilisateur

    local user_prompt="${YELLOW}${username}@${YELLOW}${hostname}:${GREEN}$location${YELLOW} >${NC}"
    location="/rvsh/host/$hostname/$username"
    
    while [ "$cmd" != "quit" ]
    do


        user_prompt="${YELLOW}${username}@${YELLOW}${hostname}:${GREEN}$(echo $location | \
        awk -F "/rvsh/host/$hostname" '{print $2}')${YELLOW}>${NC}"
        history_cmd "$user_prompt"


        tmp="$cmd"

        cmd=($tmp)
        cmd=${cmd[0]}
        param=${tmp:$((${#cmd}+1))}
        
        check_msg $username

        # lecture de la commande entree
        case "$cmd" in

        'quit' | 'q')
            
            disconnect "$username" "$hostname" "$ctime"
            return
            ;;

        'clear' | 'c')
            clear
            ;;

        'cd') 
            rvsh_cd $location $param $username $hostname
            location=$_new_location
            ;;

        'ls')
            rvsh_ls $location $param
            ;;

        'nano')
            nano $HOME$location/$param
            ;;

        'mkdir')
            rvsh_mkdir $location $param
            ;;

        'rm')
            rvsh_rm $location $param "$username"
            ;;

        'pwd')
            echo "$location"
            ;;

        'text')
            echo "[!] commande en dev"
            ;;

        'who')
            who_is_connected_on $hostname            
            ;;

        'rusers')
            rusers
            ;;
        'rhost')
            rhost
            ;;

        'connect') 
            connect_to_vm $username $param
            ;;

        'su') 
            switch_user $hostname $param 
            ;;

        'passwd') 
            change_users_passwd $username
            ;;

        'finger')
            finger $param
            ;;

        'write')
            write "$param" "$username"
            ;;

        '')
            continue
            ;;

        '?') 
            help_cmd "user"
            ;;

        *) 
            echo -e "${YELLOW}$cmd : Commande non reconnue, '?' pour afficher les commandes disponnibles${NC}"
            ;;
        esac

   done
}


handle_admin_cmd() {

    local cmd=""    # commande entree par l'utilisateur

    local admin_prompt="${BLUE}rvsh:$GREEN$location$BLUE >${NC}"
    location="/rvsh"

    
    while [ ! \( "$cmd" = "quit" -o "$cmd" = "q" \) ]; do
        # echo -en "$admin_prompt "
        # read tmp

        admin_prompt="${BLUE}rvsh:$GREEN$location$BLUE >${NC}"
        history_cmd "$admin_prompt"

        tmp="$cmd"

        cmd=($tmp)
        cmd=${cmd[0]}
        param=${tmp:$((${#cmd}+1))}
        
        # lecture de la commande entreeuse
        case "$cmd" in

        'quit' | 'q')
             
            disconnect "admin" "rvsh"
            return
            ;;

        'clear' | 'c')
            clear
            ;;

        'cd')
            rvsh_cd $location "$param" "admin" "rvsh"
            location=$_new_location
            ;;

        'ls')
            rvsh_ls $location "$param"
            ;;

        'nano')
            nano $HOME$location/$param
            ;;

        'mkdir')
            rvsh_mkdir $location $param
            ;;

        'rm')
            rvsh_rm $location $param "admin"
            ;;

        'pwd')
            echo "$location"
            ;;

        'lsc')
            lsc $param
            ;;

        'afinger')
            afinger $param
            ;;

        'host')
            host "$param"
            ;;
        'users')
        
            users $param
            ;;
    
        '')
            continue
            ;;

        '?') 
            help_cmd "admin"
            ;;

        *) 
            echo -e "${YELLOW}$cmd : Commande non reconnue, '?' pour afficher les commandes disponnibles${NC}"
            ;;
        esac
    
   done
}


# ==== FUNCTION =======================================================
#
#        NAME : help_cmd
# DESCRIPTION : permet d'afficher les commandes disponibles
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
help_cmd() {

    local mode="$1"
    local file=""

    # on selectionne le bon fichier selon
    # qu'on soit administrateur ou utilisateur
    if [ "$mode" = "admin" ]; then
        file=$ROOT/sys/help/admincmd
    else
        file=$ROOT/sys/help/userscmd
    fi
    
    # on lit le fichier d'aide associÃ© au mode et on le formate
    echo -en "$(head -2 $file)\n\n"
    echo -en "$(cat $file | awk -F':' 'NR > 2 {printf "\e[0;33m%-12s\e[0m:%s\n", $1, $2}')\n\n" # don't touch it i'm very proud of that
}


# ==== FUNCTION =======================================================
#
#        NAME : main
# DESCRIPTION : fonction principale du programme rvsh
# PARAMETER   : Pas de paramÃ¨tre.
#
# =====================================================================
main() {


    # on teste si le programme est installÃ©
    if [ ! -d $ROOT ]; then
        echo "rvsh is not installed..."
        install
    fi



    # parse the command line
    ARGS=$(getopt -o hac:iu -l "help,admin,connect:,install,uninstall" -n "rvsh.sh" -- "$@");
    eval set -- $ARGS
        
    # variables
    admin_flag=""
    user_flag=""
    install_flag=""
    uninstall_flag=""

    hostname=""
    username=""



    # not enough arguments
    if [ $# -eq 1 ]
    then 
        usage
    fi

    while true; do
        
        case "$1" in
                
        -h | --help)
        shift
        usage
        ;;
            
            
        -a | --admin)
        shift
        admin_flag="on"
        
        break
        ;;
            
        -c | --connect)
        shift
        user_flag="on"
        hostname="$1"
        shift 2

        if [ -z "$1" ] 
        then
            echo "You must specify a username"
            exit
        else
            username="$1"
        fi 
        
        break
        ;;
            

        -i | --install)
        install
        break
        ;;

        -u | --uninstall)
        uninstall
        break
        ;;


        --)
        shift;
        break;
        ;;

        esac

    done
    
    clear
    echo -e "${YELLOW}

âââââââ âââ   ââââââââââââââ  âââ
âââââââââââ   ââââââââââââââ  âââ
âââââââââââ   âââââââââââââââââââ
ââââââââââââ ââââââââââââââââââââ
âââ  âââ âââââââ âââââââââââ  âââ
âââ  âââ  âââââ  âââââââââââ  âââ
                                 
  by G. MAHFOUDI & S. JUHEL
${NC} 
" 

    # si le mode administrateur est actif 
    # il prime sur le mode utilisateur 
    #
    if [ "$admin_flag" = "on" ]; then

        connect "admin" "rvsh" && \
        write_logs "admin" "rvsh" "connected" &&\
        handle_admin_cmd 

    elif [ "$user_flag" = "on" ] && [ -z "$admin_flag" ]; then

        connect "$username" "$hostname" && \
        write_logs "$username" "$hostname" "connected" && \
        handle_users_cmd "$username" "$hostname" "$(date +%T)"

    else

        exit

    fi

}

main "$@"

# ==== EOF ============================================================